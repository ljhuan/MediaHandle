// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <gflags/gflags.h>
#include "MediaServer.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <gperftools/profiler.h>
#include "log.h"
#include "task_manager.h"
#include "type.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace  ::Media;

DEFINE_bool(debug, true, "run debug pattern");
DEFINE_uint64(port, 8888, "default port is 9999");
DEFINE_string(imgpath, "/mnt/unused/ftms/images/pic3", "default path");
DEFINE_bool(running, true, "server running status");

class MediaServerHandler : virtual public MediaServerIf {
 public:
  MediaServerHandler() {
    // Your initialization goes here
  }

  /**
   * login server, return token
   * 
   * @param ip
   */
  void login(std::string& _return, const std::string& ip) {
      // Your implementation goes here
      _return = "ftoken";
      LOG(INFO) << "login";
  }

  /**
   * acquire server ip
   */
  void getServerIP(std::string& _return) {
      LOG(INFO) << "get server ip";
  }

  /**
   * shutdown server
   */
  void shutdownServer() {
      FLAGS(running) = false;
      LOG(INFO) << "server is shuting down ...";
  }

  /**
   * create task, return taskid
   * 
   * @param path
   */
  void creatTask(std::string& _return, const std::string& info) {
      auto mgr = Singleton<TaskManager>::instance();
      std::string taskID;
      mgr->createTask(info, taskID);
      mgr->startTask(taskID);
      _return = taskID;
  }

  /**
   * delete task with taskid
   * 
   * @param taskid
   */
  void deleteTask(const std::string& taskid) {
      auto mgr = Singleton<TaskManager>::instance();
      mgr->stopTask(taskid);
      mgr->deleteTask(taskid);
  }
};

// check FLAGS_run every 1 sec
void signalProc(std::shared_ptr<TSimpleServer> server) {
    LOG(INFO) << "mp server is running ...";
    while (FLAGS(running)) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
    server->stop();
    auto mgr = Singleton<TaskManager>::instance();
    mgr->stopAll();
    return;
}

int main(int argc, char **argv) {
    // gflag init
    std::string cfgPath = "/opt/mserver.conf";
    boost::filesystem::path bstPath(cfgPath.c_str());
    if (boost::filesystem::exists(bstPath) &&
        boost::filesystem::is_regular(bstPath)) {
        google::SetCommandLineOption("flagfile", bstPath.c_str());
    }
    google::ParseCommandLineFlags(&argc, &argv, true);

    if (FLAGS(debug)) {
        std::cout << "performance testing ...\n";
        ProfilerStart("my.prof");
    }

    // log init
    Singleton<Common::MediaLog>::instance(argv[0]);

    // thrift init
    int port = FLAGS(port);
    boost::shared_ptr<MediaServerHandler> handler(new MediaServerHandler());
    boost::shared_ptr<TProcessor> processor(new MediaServerProcessor(handler));
    boost::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    boost::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    boost::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
    std::shared_ptr<TSimpleServer> server(new TSimpleServer(processor, serverTransport, transportFactory, protocolFactory));

    // signal deal
    // todo --> server.stop()
    // simple deal
    auto t = std::thread(signalProc, server);

    // thrift start
    server->serve();

    if (t.joinable()) {
        t.join();
    }
    if (FLAGS(debug)) {
        ProfilerStop();
    }
    return 0;
}

